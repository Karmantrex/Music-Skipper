#!/usr/bin/env python3
import os
import sys
import time
import subprocess
import signal
import logging
from pathlib import Path

# Configuration
PID_FILE = Path("/tmp/auto_next_soundcloud.pid")
LOG_FILE = Path("/tmp/auto_next_soundcloud.log")
SKIP_INTERVAL = 120  # 2 minutes in seconds

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(LOG_FILE),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

def send_next_command():
    """Send next track command using AppleScript with error handling."""
    # First check if Chrome is running
    applescript_check_chrome = '''
    tell application "System Events"
        return (name of processes) contains "Google Chrome"
    end tell
    '''
    
    try:
        chrome_check = subprocess.run(
            ["osascript", "-e", applescript_check_chrome], 
            capture_output=True, 
            text=True, 
            timeout=5
        )
        
        if chrome_check.returncode != 0 or "false" in chrome_check.stdout.lower():
            logger.warning("Chrome is not running - skipping this attempt")
            return "CHROME_NOT_RUNNING"
            
    except Exception as e:
        logger.warning(f"Could not check if Chrome is running: {e}")
        return "CHROME_CHECK_FAILED"
    
    # Use the correct NEXT button selector found by the inspector
    next_button_selector = ".skipControl.sc-ir.playControls__control.playControls__next.sc-button.sc-button-secondary.sc-button-large.sc-button-icon.sc-mr-3x.skipControl__next"
    
    # Modified script that ONLY works when SoundCloud is actively playing
    applescript_click = f'''
    tell application "Google Chrome"
        -- Don't activate Chrome, work in background
        set playingTabs to {{}}
        
        -- Find SoundCloud tabs that are currently playing
        repeat with w from 1 to count of windows
            repeat with t from 1 to count of tabs of window w
                tell tab t of window w
                    if URL contains "soundcloud.com" then
                        -- Found SoundCloud tab, check if it's actively playing
                        try
                            set playState to execute javascript "
                                // Check multiple ways to detect if music is playing
                                var playBtn = document.querySelector('.playControl, .playControls__play');
                                var pauseBtn = document.querySelector('.playControl__pause, .playControls__pause');
                                
                                // Method 1: Look for playing class
                                if (playBtn && playBtn.classList.contains('playing')) {{
                                    'PLAYING';
                                }} else if (playBtn && playBtn.classList.contains('paused')) {{
                                    'PAUSED';
                                }} else {{
                                    // Method 2: Check if pause button is visible (means playing)
                                    var playControlDiv = document.querySelector('.playControl');
                                    if (playControlDiv && playControlDiv.classList.contains('playing')) {{
                                        'PLAYING';
                                    }} else {{
                                        'PAUSED';
                                    }}
                                }}
                            "
                            
                            if playState contains "PLAYING" then
                                set end of playingTabs to {{window:w, tab:t}}
                            end if
                        end try
                    end if
                end tell
            end repeat
        end repeat
        
        -- Only proceed if we found actively playing SoundCloud tabs
        if (count of playingTabs) = 0 then
            return "NO_PLAYING_SOUNDCLOUD"
        end if
        
        -- Use the first playing SoundCloud tab
        set targetTab to item 1 of playingTabs
        
        -- Click next on the playing tab
        tell tab (tab of targetTab) of window (window of targetTab)
            execute javascript "
                var btn = document.querySelector('{next_button_selector}');
                if (btn && btn.offsetParent !== null && !btn.disabled) {{
                    btn.click();
                    'SUCCESS';
                }} else {{
                    'NOT_FOUND';
                }}
            "
            return result
        end tell
    end tell
    '''
    
    try:
        result = subprocess.run(
            ["osascript", "-e", applescript_click], 
            capture_output=True, 
            text=True, 
            timeout=20
        )
        
        if result.returncode == 0:
            output = result.stdout.strip()
            if "SUCCESS" in output:
                logger.info("Next track clicked on PLAYING SoundCloud tab")
                return True
            elif "NO_PLAYING_SOUNDCLOUD" in output:
                logger.info("SoundCloud found but no music currently playing - skipping")
                return "NO_PLAYING_SOUNDCLOUD"
            elif "NO_SOUNDCLOUD_TAB" in output:
                logger.warning("No SoundCloud tab found in Chrome")
                return "NO_SOUNDCLOUD_TAB"
            else:
                logger.warning("Next button not found on playing SoundCloud tab")
                return "BUTTON_NOT_FOUND"
        else:
            logger.error(f"AppleScript error: {result.stderr}")
            return False
            
    except Exception as e:
        logger.error(f"Error clicking next button: {e}")
        return False
    
    try:
        result = subprocess.run(
            ["osascript", "-e", applescript_click], 
            capture_output=True, 
            text=True, 
            timeout=15
        )
        
        if result.returncode == 0:
            output = result.stdout.strip()
            if "SUCCESS:" in output:
                logger.info(f"Next track command sent successfully: {output}")
                return True
            else:
                logger.error(f"Could not click next button: {output}")
                return False
        else:
            logger.error(f"AppleScript error: {result.stderr}")
            return False
            
    except subprocess.TimeoutExpired:
        logger.error("AppleScript command timed out")
        return False
    except Exception as e:
        logger.error(f"Failed to send next command: {e}")
        return False

def cleanup_pid_file():
    """Clean up PID file if process is not running."""
    if PID_FILE.exists():
        try:
            with open(PID_FILE, "r") as f:
                pid = int(f.read().strip())
            
            # Check if process is actually running
            os.kill(pid, 0)  # This will raise ProcessLookupError if process doesn't exist
            
        except (ProcessLookupError, ValueError, OSError):
            logger.info("Cleaning up stale PID file")
            PID_FILE.unlink()
            return True
    return False

def setup_signal_handlers():
    """Setup signal handlers for graceful shutdown."""
    def signal_handler(signum, frame):
        logger.info(f"Received signal {signum}, shutting down gracefully")
        if PID_FILE.exists():
            PID_FILE.unlink()
        sys.exit(0)
    
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)

def daemon_loop():
    """Main daemon loop with error recovery."""
    setup_signal_handlers()
    consecutive_real_failures = 0
    consecutive_button_failures = 0
    max_real_failures = 5
    max_button_failures = 3  # Only try 3 times if button not found
    
    logger.info("Starting auto-skip daemon")
    
    while True:
        try:
            result = send_next_command()
            
            if result is True:
                # Successful click - reset all counters
                consecutive_real_failures = 0
                consecutive_button_failures = 0
                logger.info("Song skipped successfully")
                
            elif result == "BUTTON_NOT_FOUND":
                # Button not found - likely interface changed
                consecutive_button_failures += 1
                logger.warning(f"Button not found. Attempt {consecutive_button_failures}/{max_button_failures}")
                
                if consecutive_button_failures >= max_button_failures:
                    logger.error("Button not found after 3 attempts. SoundCloud interface may have changed.")
                    logger.error("Please run: python3 inspect_soundcloud.py to find new button selector")
                    logger.error("Stopping daemon - manual fix required")
                    break
                    
            elif result in ["CHROME_NOT_RUNNING", "NO_SOUNDCLOUD_TAB", "CHROME_CHECK_FAILED"]:
                # Environmental issues - keep trying indefinitely
                logger.info(f"Skipping attempt: {result} - will keep trying")
                # Reset button failure counter since this isn't a button issue
                consecutive_button_failures = 0
                
            elif result == "NO_PLAYING_SOUNDCLOUD":
                # SoundCloud exists but not playing - don't count as failure
                logger.info("SoundCloud paused - waiting for music to start playing")
                # Reset button failure counter since this isn't a button issue
                consecutive_button_failures = 0
                
            else:
                # Real script/system failure
                consecutive_real_failures += 1
                logger.error(f"Real failure occurred. Count: {consecutive_real_failures}")
                if consecutive_real_failures >= max_real_failures:
                    logger.error(f"Too many consecutive real failures ({max_real_failures}), stopping daemon")
                    break
            
            time.sleep(SKIP_INTERVAL)
            
        except KeyboardInterrupt:
            logger.info("Received keyboard interrupt")
            break
        except Exception as e:
            logger.error(f"Unexpected error in daemon loop: {e}")
            consecutive_real_failures += 1
            if consecutive_real_failures >= max_real_failures:
                break
            time.sleep(10)  # Short delay before retrying
    
    # Cleanup
    if PID_FILE.exists():
        PID_FILE.unlink()
    logger.info("Daemon stopped")

def start():
    """Start the auto-skip daemon."""
    # Clean up stale PID files
    cleanup_pid_file()
    
    if PID_FILE.exists():
        print("Script is already running.")
        return 1
    
    # Test AppleScript before forking
    logger.info("Testing next button click...")
    if not send_next_command():
        print("Failed to click next button. Please check:")
        print("1. SoundCloud is open in Chrome")
        print("2. Music is currently playing")
        print("3. Chrome is the active application")
        return 1
    
    print("✅ Next button click test successful!")
    
    try:
        pid = os.fork()
        if pid > 0:
            # Parent process - store child PID
            with open(PID_FILE, "w") as f:
                f.write(str(pid))
            print(f"Started auto-skip daemon with PID {pid}")
            print(f"Songs will be skipped every {SKIP_INTERVAL} seconds (2 minutes)")
            print(f"Logs will be written to: {LOG_FILE}")
            return 0
        else:
            # Child process - run daemon loop
            # Redirect stdout/stderr for proper daemonization
            with open('/dev/null', 'w') as devnull:
                os.dup2(devnull.fileno(), sys.stdout.fileno())
                os.dup2(devnull.fileno(), sys.stderr.fileno())
            
            daemon_loop()
            return 0
            
    except OSError as e:
        logger.error(f"Failed to fork process: {e}")
        return 1

def stop():
    """Stop the auto-skip daemon."""
    if not PID_FILE.exists():
        print("Script is not running.")
        return 1
    
    try:
        with open(PID_FILE, "r") as f:
            pid = int(f.read().strip())
        
        # Try graceful shutdown first
        os.kill(pid, signal.SIGTERM)
        
        # Wait a bit for graceful shutdown
        time.sleep(2)
        
        # Check if process is still running
        try:
            os.kill(pid, 0)
            # Still running, force kill
            logger.warning("Process didn't respond to SIGTERM, using SIGKILL")
            os.kill(pid, signal.SIGKILL)
        except ProcessLookupError:
            # Process already stopped
            pass
        
        print(f"Stopped auto-skip daemon (PID {pid})")
        return 0
        
    except (ProcessLookupError, ValueError) as e:
        print(f"Error stopping process: {e}")
        return 1
    except Exception as e:
        logger.error(f"Unexpected error while stopping: {e}")
        return 1
    finally:
        # Always try to clean up PID file
        if PID_FILE.exists():
            PID_FILE.unlink()

def status():
    """Check the status of the auto-skip daemon."""
    if not PID_FILE.exists():
        print("Auto-skip daemon is not running.")
        return 1
    
    try:
        with open(PID_FILE, "r") as f:
            pid = int(f.read().strip())
        
        # Check if process is actually running
        os.kill(pid, 0)
        print(f"Auto-skip daemon is running with PID {pid}")
        print(f"Log file: {LOG_FILE}")
        return 0
        
    except (ProcessLookupError, ValueError):
        print("Auto-skip daemon is not running (stale PID file found).")
        cleanup_pid_file()
        return 1

def test():
    """Test clicking the next button once."""
    print("Testing next button click...")
    if send_next_command():
        print("✅ SUCCESS! Next button clicked successfully.")
        return 0
    else:
        print("❌ FAILED! Could not click next button.")
        print("Make sure:")
        print("1. SoundCloud is open in Chrome")
        print("2. Music is currently playing")
        print("3. Chrome is the active application")
        return 1

def main():
    """Main entry point."""
    if len(sys.argv) != 2:
        print("Usage: python soundcloud_next.py [start|stop|status|test]")
        print("  start  - Start the auto-skip daemon")
        print("  stop   - Stop the auto-skip daemon")
        print("  status - Check daemon status")
        print("  test   - Test clicking next button once")
        return 1
    
    command = sys.argv[1].lower()
    
    if command == "start":
        return start()
    elif command == "stop":
        return stop()
    elif command == "status":
        return status()
    elif command == "test":
        return test()
    else:
        print("Invalid argument. Use 'start', 'stop', 'status', or 'test'.")
        return 1

if __name__ == "__main__":
    sys.exit(main())
